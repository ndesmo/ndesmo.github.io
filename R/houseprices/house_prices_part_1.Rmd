---
title: 'House prices: part one'
output:
  md_document:
    variant: markdown_github
#output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(ggplot2)
library(reshape2)
```


## Overview

In the following few posts I will be doing simple exploratory data analysis of the [Ames Housing dataset](https://ww2.amstat.org/publications/jse/v19n3/decock.pdf) used in the Kaggle competition [House Prices: Advanced Regression Techniques](https://www.kaggle.com/c/house-prices-advanced-regression-techniques). In later posts, I will go on to run statistical models on the data. This is my first blog post here so it's also an exercise in creating blog posts!

The problem is to try to correctly predict the house prices in the test dataset by training a regression model on the training data.

I will soon do an exploratory data analysis of the data, however to begin with, the data should be cleaned. In particular, the empty values should be filled in.

First, let's load the data.

``` {r load-data}
library(dplyr)
library(ggplot2)
library(reshape2)

train <- read.csv('train.csv', stringsAsFactors = F)
test <- read.csv('test.csv', stringsAsFactors = F)
```

### Columns

Here are the columns available in the dataset:

``` {r columns}
names(train)
```

The last column "SalePrice" is the one we will be measuring so we won't include this in the full set. We bin the ID column straight away as it's not needed.

``` {r union}
full <-
  train %>% select(-Id, -SalePrice) %>%
  bind_rows(test %>% select(-Id))
```

## Data cleaning

We look for missing values and try to fill these in

``` {r summary}
full %>% 
  select(which(sapply(full, function(x)any(is.na(x))))) %>%
  sapply(function(x)sum(ifelse(is.na(x), 1, 0))) %>%
  sort(decreasing=T)
```

### PoolQC missing values

``` {r poolqc}
full %>%
  select(PoolQC) %>%
  group_by(PoolQC) %>%
  summarise(Count = n())
```

What to fill in the NA's with? We will go for a default missing value. The data dictionary says that 'NA' means "no pool" so we'll go with that.

``` {r poolQC}
full <-
  full %>%
  mutate(PoolQC = ifelse(is.na(PoolQC), 'None', PoolQC))
```

What is the situation with PoolArea?

``` {r poolArea}
full %>% filter(PoolQC == 'None', PoolArea > 0) %>% select(PoolArea)
```

There are 3 instances of Pools with non-zero area but "don't exist". To fix this let's look at the relationship between PoolQC and PoolArea

``` {r poolqc-poolarea}
full %>%
  filter(PoolQC != 'None') %>% 
  ggplot(aes(x=factor(PoolQC), y=PoolArea)) + 
  geom_boxplot(fill='cornflowerblue')
```

So it looks like the 3 cases of non-existent pools with area > 0 should all be given PoolQC = 'Ex'

```{r poolQC-fix}
full <-
  full %>%
  mutate(PoolQC = ifelse(PoolQC == 'None' & PoolArea > 0, 'Ex', PoolQC))
```

### MiscFeature missing values

Next on the list is MiscFeature. The data dictionary describes this as "Miscellaneous feature not covered in other categories". Lets do a count of each value:

``` {r misc-feature}
full %>%
  group_by(MiscFeature) %>%
  summarise(Count = n())
```

I think we're good to go ahead and fill in the missing values of MiscFeature with 'None'.

``` {r fill-miscgfeature}
full <-
  full %>%
  mutate(MiscFeature = ifelse(is.na(MiscFeature), 'None', MiscFeature))
```

### MiscFeature Second Garages

Value of Gar2 means there is a second Garage. Let's check whether this is accurately represented in the data

``` {r gar2}
full  %>%
  filter(MiscFeature == 'Gar2')%>% 
  select(GarageType, GarageYrBlt, GarageFinish, GarageCars, GarageArea, GarageQual, GarageCond)
```

Good, so there's no existence of 2nd garages without a first. However I wonder if there are garages with more Cars in them without room for them.

``` {r cars-garage}
full %>% ggplot(aes(x = GarageArea, y=GarageCars)) + geom_point(colour = 'cornflowerblue')
```

This looks to be behaving well. There dont seem to be any outliers towards the left and top of the graph.

### FireplaceQu missing values

We use the Fireplaces column to fix the FireplaceQu missing values

``` {r fireplaces}
full %>%
  filter(is.na(FireplaceQu), Fireplaces > 0) %>%
  select(Fireplaces, FireplaceQu)
```

Hence, we assign all blank FireplaceQu to 'None'.

``` {r fireplacequ}
full <-
  full %>%
  mutate(FireplaceQu = ifelse(is.na(FireplaceQu), 'None', FireplaceQu))
```

### LotFrontage missing values

Does lack of a value mean 0 feet as lot frontage?

``` {r lotfrontage}
full %>%
  filter(is.na(LotFrontage) | LotFrontage == 0) %>%
  summarise(Count = n())
```

Since there are only NA's and no 0's then let's assume so

``` {r lotfrontagefill}
full <-
  full %>%
  mutate(LotFrontage = ifelse(is.na(LotFrontage), 0, LotFrontage))
```

### Garages

``` {r garages}
full %>%
  filter(is.na(GarageType) |
           is.na(GarageYrBlt) |
           is.na(GarageFinish) |
           is.na(GarageCars) |
           is.na(GarageArea) |
           is.na(GarageQual) |
           is.na(GarageCond)) %>%
  group_by(GarageType, GarageYrBlt, GarageFinish, GarageCars,
           GarageArea, GarageQual, GarageCond) %>%
  summarise(Count = n()) %>%
  knitr::kable()
```

So we have 2 cases of Detached garages, 1 with entries for GarageCars and GarageArea, and another for no other Garage entries. We also have 157 cases where there are no entries for anything, so this looks like no garage.

We'll fill in the "no garages" first. For the year we will use the YearBuilt

``` {r nogarages}
full <-
  full %>%
  transform(GarageType = ifelse(is.na(GarageType), 'None', GarageType),
            GarageYrBlt = ifelse(is.na(GarageYrBlt), YearBuilt, GarageYrBlt),
            GarageFinish = ifelse(is.na(GarageFinish), 'None', GarageFinish),
            GarageCars = ifelse(is.na(GarageCars), 'None', 0),
            GarageArea = ifelse(is.na(GarageArea), 'None', 0),
            GarageQual = ifelse(is.na(GarageQual), 'None', GarageQual),
            GarageCond = ifelse(is.na(GarageCond), 'None', GarageCond))
         
```

### Basements cleaning

Next up, the basement. Let's see where the null values occur

``` {r basements}
full %>%
  filter(is.na(BsmtQual) |
           is.na(BsmtCond) |
           is.na(BsmtExposure) |
           is.na(BsmtFinType1) |
           is.na(BsmtFinSF1) |
           is.na(BsmtFinType2) |
           is.na(BsmtFinSF2) | 
           is.na(BsmtUnfSF) |
           is.na(BsmtFullBath) |
           is.na(BsmtHalfBath) |
           is.na(TotalBsmtSF)) %>%
  group_by(BsmtQual, BsmtCond, BsmtExposure, BsmtFinType1, BsmtFinSF1,
           BsmtFinType2, BsmtFinSF2, BsmtUnfSF, BsmtFullBath, BsmtHalfBath,
           TotalBsmtSF) %>%
  summarise(Count = n()) %>%
  knitr::kable()
```

From the above we see:

* 2 cases of No Basement (BsmtQual) where BsmtCond is not No Basement - takes values of Fair/Typical
* These cases occur when the BsmtFinType1 is Unfinished. Square footage is positive here.
* 5 cases BsmtFinType2 = BsmtFinType1 which shouldn't happen unless both are NA. Does this happen elsewhere?
* Check that BsmtFinSF1 + BsmtFinSF2 + BsmtUnfSF = TotalBsmtSF

First, let's check for cases of BsmtFinType2 = BsmtFinType1 and check that total SF is correct

``` {r bsmtfintype2}
full %>%
  filter(BsmtFinType2 == BsmtFinType1) %>%
  group_by(BsmtFinType1, BsmtFinType2) %>%
  summarise(BsmtFinSF1 = sum(BsmtFinSF1),
            BsmtFinSF2 = sum(BsmtFinSF2),
            BsmtUnfSF = sum(BsmtUnfSF),
            TotalBsmtSF = sum(TotalBsmtSF),
            ChkTotal = sum(BsmtFinSF1) + sum(BsmtFinSF2) + sum(BsmtUnfSF)) %>%
  knitr::kable()
```

The check passed, so let's set BsmtFinType2 to NA, BsmtFinSF1 to BsmtFinSF1 + BsmtFinSF2, and BsmtFinSF2 to 0.

``` {r bsmtfintype}
full <-
  full %>%
  transform(BsmtFinType2 = ifelse(BsmtFinType2 == BsmtFinType1, NA, BsmtFinType2),
            BsmtFinSF1 = ifelse(BsmtFinType2 == BsmtFinType1, BsmtFinSF1 + BsmtFinSF2, BsmtFinSF1),
            BsmtFinSF2 = ifelse(BsmtFinType2 == BsmtFinType1, 0, BsmtFinSF2))
```

Let's check across the dataset that the total basement SF is correct:

``` {r totalbsmtsf}
full %>%
  filter(TotalBsmtSF != BsmtFinSF1 + BsmtFinSF2 + BsmtUnfSF) %>%
  summarise(Count = n())
```

All good then. Let's perform the updates:

* Rows 2-4 BsmtExposure indicate No Basement, however this should be No Exposure
* One row of 77 cases of completely null values - let's fill these with the default null values
* Rows 8,9 fill in BsmtQual with 'TA'
* Rows 2-4 BsmtFinType2 set to NA, then convert all NA's to 'None'
* NA's in BsmtFinSF1, BsmtFinSF2, BsmtUnfSF, TotalBsmtSF, BsmtFullBath, BsmtHalfBath should be 0
* NA's in BsmtQual, BsmtCond, BsmtExposure, BsmtFinType1, BsmtFinType2 should be 'None'

``` {r bsmtupdates}
full <-
  full %>%
  mutate(BsmtExposure = ifelse(is.na(BsmtExposure) & BsmtQual == 'Gd', 'No', BsmtExposure),
         BsmtFinType2 = ifelse(is.na(BsmtExposure) & BsmtQual == 'Gd', NA, BsmtFinType2),
         
         BsmtFinSF1 = ifelse(is.na(BsmtFinSF1), 0, BsmtFinSF1),
         BsmtFinSF2 = ifelse(is.na(BsmtFinSF2), 0, BsmtFinSF2),
         BsmtUnfSF = ifelse(is.na(BsmtUnfSF), 0, BsmtUnfSF),
         TotalBsmtSF = ifelse(is.na(TotalBsmtSF), 0, TotalBsmtSF),
         BsmtFullBath = ifelse(is.na(BsmtFullBath), 0, BsmtFullBath),
         BsmtHalfBath = ifelse(is.na(BsmtHalfBath), 0, BsmtHalfBath),
         
         BsmtQual = ifelse(is.na(BsmtQual), 'None', BsmtQual),
         BsmtCond = ifelse(is.na(BsmtCond), 'None', BsmtCond),
         BsmtExposure = ifelse(is.na(BsmtExposure), 'None', BsmtExposure),
         BsmtFinType1 = ifelse(is.na(BsmtFinType1), 'None', BsmtFinType1),
         BsmtFinType2 = ifelse(is.na(BsmtFinType2), 'None', BsmtFinType2))
         
```

Now what's left to fill in?
``` {r summary2}
full %>% 
  select(which(sapply(full, function(x)any(is.na(x))))) %>%
  sapply(function(x)sum(ifelse(is.na(x), 1, 0))) %>%
  sort(decreasing=T)
```

### Alley and fence

``` {r alley}
full %>%
  group_by(Alley, Fence) %>%
  summarise(Count = n()) %>%
  knitr::kable()
```

NA means 'no alley access' or 'no fence' so let's fill that with 'None'

``` {r noalley}
full <-
  full %>%
  mutate(Alley = ifelse(is.na(Alley), 'None', Alley),
         Fence = ifelse(is.na(Fence), 'None', Fence))
```

### Mason veneer

``` {r masvnr}
full %>%
  group_by(MasVnrType, ifelse(is.na(MasVnrArea), 0, 1)) %>%
  summarise(Count = n()) %>%
  knitr::kable()
```

Fill this in:

``` {r fillmsn}
full <-
  full %>%
  mutate(MasVnrType = ifelse(is.na(MasVnrType), 'None', MasVnrType),
         MasVnrArea = ifelse(is.na(MasVnrArea), 0, MasVnrArea))
```

### MSZoning

Getting the distribution of MSZoning, we see there are 4 NA's here:

``` {r MSZoning}
full %>%
  group_by(MSZoning) %>%
  summarise(Count = n()) %>%
  knitr::kable()
```

Now, let's see what the most common value of MSZoning is per MSSubClass, and select only the MSSubClass where MSZoning is NA.

``` {r MSZoning2}
Mode <- function(x) {
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}

full %>%
  group_by(MSSubClass) %>%
  summarise(AvgZoning = Mode(MSZoning)) %>%
  inner_join(
    full %>%
      filter(is.na(MSZoning)) %>%
      distinct(),
    by = "MSSubClass"
  ) %>%
  select(MSSubClass, AvgZoning) %>%
  distinct()
```

Let's update the values with this:

``` {r updateMSZoning}
full <-
  full %>%
  mutate(MSZoning = ifelse(is.na(MSZoning), ifelse(MSSubClass == 20, 'RL', 'RM'), MSZoning))
```


 Utilities  Functional Exterior1st Exterior2nd  Electrical KitchenQual    SaleType
 
### The rest

``` {r therest}
full %>%
  filter(is.na(Utilities) |
           is.na(Functional) |
           is.na(Exterior1st) |
           is.na(Exterior2nd) |
           is.na(Electrical) |
           is.na(KitchenQual) |
           is.na(SaleType)) %>%
  group_by(Utilities, Functional, Exterior1st, Exterior2nd, Electrical, KitchenQual, SaleType) %>%
  summarise(Count = n()) %>%
  knitr::kable()
```

Let's fill the rest in with the most common value

``` {r restfill}
full <-
  full %>%
  mutate(Utilities = ifelse(is.na(Utilities), Mode(Utilities), Utilities),
         Functional = ifelse(is.na(Functional), Mode(Functional), Functional),
         Exterior1st = ifelse(is.na(Exterior1st), Mode(Exterior1st), Exterior1st),
         Exterior2nd = ifelse(is.na(Exterior2nd), Mode(Exterior2nd), Exterior2nd),
         Electrical = ifelse(is.na(Electrical), Mode(Electrical), Electrical),
         KitchenQual = ifelse(is.na(KitchenQual), Mode(KitchenQual), KitchenQual),
         SaleType = ifelse(is.na(SaleType), Mode(SaleType), SaleType))
```

### Update the train and test data

Now that we have fixed the missing values in the train and test data, we may update the original datasets so that we are ready to begin the analysis.

``` {r update-train-test}
t <- nrow(train)
f <- nrow(full)

SP <- train$SalePrice

train <- full[1:t,]
test <- full[t+1:f,]

train$SalePrice <- SP
```

We are now ready to do some exploratory analysis.